/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Simulink Coder, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Simulink Coder User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Fri Apr  4 12:34:54 2014
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <math.h>
// #include "mex.h"
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 4
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
/* extern double func(double a); */
/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/*
 * Output functions
 *
 */
void sfunc_path_follow_Outputs_wrapper(const real_T *pose,
                          const real_T *path,
                          const real_T *exec_path,
                          real_T *steer_angle,
                          real_T *drive_speed,
                          const real_T  *xD)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
int    i;               /* counter dummy variable */    
    
double from_node[6];    /* 1-dim C array */
double to_node[6];      /* 1-dim C array */
int    path_index;      /* xD[0], the first discrete state variable */
int    direction;       /* travelling direction, 1 for forward, -1 for backward */
double theta;           /* orientation of vehicle */
double theta_path;      /* orientation of nearest path point */ 
double theta_err;       /* orientation error */
double new_steer_angle; /* new steering angle */
double cte;             /* cross-track error */
double k;               /* gain parameter for steering control law */

/* FOR CTE CALCULATIONS */
double STRAIGHT_THRESH; /* threshold for assuming straight driving */
double ROBOT_LENGTH;    /* robot length */
double phi;             /* required steering angle */
double dist;            /* required driving distance between nodes */
double beta;            /* turning angle between nodes */
double radius;          /* turning radius */
double CX;              /* x-coord of centre of turning circle */
double CY;              /* y-coord of centre of turning circle */
double v_from[2];       /* vector between centre and from_node */
double v_to[2];         /* vector between centre and to_node */
double angle;           /* angle between v_from and v_to, ctr-clockwise from v_from to v_to */

if (exec_path[0] == 0 || xD[2] == 1) {
    steer_angle[0] = 0;
    drive_speed[0] = 0;
    return;
} else {
    path_index = xD[0];

    /* copy the nodes from the path */
    for (i=0; i<6; i++) {
        from_node[i] = path[path_index*6 + i];
        to_node[i] = path[(path_index+1)*6 + i];
    }

    /* execute the FUCK out of this path. */
//     mexPrintf("PATH_FOL: from_node=[%.2f,%.2f,%.2f,%.2f,%.2f,%.2f]\n", from_node[0], from_node[1], from_node[2], from_node[3], from_node[4], from_node[5]);  
//     mexPrintf("PATH_FOL: to_node=[%.2f %.2f %.2f %.2f %.2f %.2f]\n", to_node[0], to_node[1], to_node[2], to_node[3], to_node[4], to_node[5]);
//     mexPrintf("PATH_FOL: pose=[%.2f %.2f %.2f %.2f]\n", pose[0], pose[1], pose[2], pose[3]);
    

    /* set drive speed */
    direction = (to_node[3] > 0) ? 1 : -1;
    drive_speed[0] = direction * 20;

    /* Calculate the steering angle */

    /* Stanley Method from the DARPA Grand Challenge
     * 
     * Stanley method is a nonlinear feedback function of the cross track
     * error e_fa, measured from the centre of the front axle to the nearest
     * path point (cx, cy), for which exponential convergence can be shown.
     * Co-locating the point of control with the steered front wheels allows
     * for an intuitive control law, where the first term simply keeps the
     * wheels aligned with the given path by setting the steering angle
     * phi equal to the heading error:
     *          theta_err = theta - theta_path
     * where theta is the heading of the vehicle and theta_path is the
     * heading of the path at (cx, cy). When e_fa is non-zero, the second
     * term adjusts phi such that the intended trajectory intersects the
     * path tangent from (cx, cy) at k*v units from the front axle. The
     * resulting control law is given as
     *          phi = theta_err + atan(k*e_fa / v)
     * where k is a gain parameter and v is the vehicle's speed. As e_fa
     * increases, the wheels are steered further towards the path.
     *    Snider, Jarrod. Automatic Steering Methods for Autonomous
     *    Automobile Path Tracking. CMU-RI-TR-09-08 */

    theta = pose[2];

    /* Stanley Method from the DARPA Grand Challenge
    %
    %   The cross-track error cte(t) measures the lateral distance of the center of
    % the vehicle's front wheels from the nearest point on the trajectory. In
    % the absence of any lateral errors, the control law points the front
    % wheels parallel to the planner trajectory. 
    %   The basic steering angle control law is given by 
    %         delta(t) = psi(t) + arctan[k*cte(t) / u(t)]
    % where psi is the orientation of the nearest path point relative to the
    % vehicle's own orientation, k is a gain parameter, and u(t) is the speed
    % of the vehicle. The second term adjusts the steering in (nonlinear)
    % proportion to the cross-track error cte(t): the larger this error, the
    % stronger the steering response toward the trajectory.
    %   With this control law, the error converges exponentially to cte(t)=0,
    % and the parameter k determines the rate of convergence. 
    %%% Thrun et. al. Stanley: The Robot that Won the DARPA Grand Challenge */

    /* Cross-track error is calculated via standard orientation (right-hand rule). */
    STRAIGHT_THRESH = 0.025;
    ROBOT_LENGTH = 0.17;

    phi = to_node[4];
    dist = to_node[5];

    if (fabs(phi) > STRAIGHT_THRESH) {
        /**************************************************************
         * Assume we're moving along an arc.
         * 
         * To get path orientation, instead of actually determining the
         * nearest point, simply get the angle between two vectors: 
         * vector between centre and from_node, and between centre and 
         * current pose. Since we're assumed to be travelling at a fixed
         * steering angle we can assume that the path orientation at the
         * nearest point is just the initial orientation plus that angle.
         *
         * To get the cross-track error, since we're travelling in a 
         * circle of fixed radius, the CTE to the nearest point is just
         * equal to the distance from the centre minus the radius of
         * the circle.
         *************************************************************/

        beta = dist*tan(phi)/ROBOT_LENGTH;
        radius = dist/beta;

        CX = from_node[0] - sin(from_node[2]) * radius;                  
        CY = from_node[1] + cos(from_node[2]) * radius;

        v_from[0] = from_node[0]-CX;
        v_from[1] = from_node[1]-CY;
        v_to[0] = pose[0]-CX;
        v_to[1] = pose[1]-CY;

        angle = fmod(atan2(v_from[0]*v_to[1]-v_to[0]*v_from[1],v_from[0]*v_to[0]+v_from[1]*v_to[1]),2.0*M_PI);

        theta_path = fmod(from_node[2] + angle, 2.0*M_PI);
        cte = sqrt(v_to[0]*v_to[0] + v_to[1]*v_to[1]) - radius;
        
//         mexPrintf("PATH_FOL: beta=%.2f, radius=%.2f, CX=%.2f, CY=%.2f, angle=%.2f, theta_path=%.2f, cte=%.2f\n", beta, radius, CX, CY, angle, theta_path, cte );  

    } else {           
        /**************************************************************
         * Otherwise, we're moving virtually straight.
         *
         * If calculated as above, we would have beta=0 and radius=Inf.
         * 
         * In this case, the orientation of the path is the same as the
         * orientation of the from_node, and the cross-track error is
         * the perpendicular distance to that line. 
         *
         * http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html
         *************************************************************/
        theta_path = from_node[2];
        cte = ((to_node[0] - from_node[0])*(from_node[1] - pose[1]) - (from_node[0] - pose[0])*(to_node[1] - from_node[1])) / sqrt( pow(to_node[0]-from_node[0],2) + pow(to_node[1]-from_node[1],2) );
    }

    theta_err = theta - theta_path;
    
    k = 100.0;
    
    /* flip the sign on the steering angle */
    new_steer_angle = - theta_err + atan(k * cte / drive_speed[0]);
    //new_steer_angle = phi + atan(k * cte / drive_speed[0]);
    
    if (new_steer_angle > 0) new_steer_angle = fmod(new_steer_angle + M_PI, 2.0*M_PI) - M_PI;
    else new_steer_angle = fmod(new_steer_angle - M_PI, 2.0*M_PI) + M_PI;
    
    if (new_steer_angle < -0.6981) new_steer_angle = -0.6981;
    if (new_steer_angle > 0.6981) new_steer_angle = 0.6981;

    steer_angle[0] = new_steer_angle;
//     mexPrintf("PATH_FOL: vel=%.2f, steer=%.2f, cte=%.5f\n", drive_speed[0], steer_angle[0], cte);    
}
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */
}

/*
  * Updates function
  *
  */
void sfunc_path_follow_Update_wrapper(const real_T *pose,
                          const real_T *path,
                          const real_T *exec_path,
                          const real_T *steer_angle,
                          const real_T *drive_speed,
                          real_T *xD)
{
  /* %%%-SFUNWIZ_wrapper_Update_Changes_BEGIN --- EDIT HERE TO _END */
int    i;               /* counter dummy variable */  

int    path_ind;        /* value of xD[0] */
double prev_dist_to;    /* value of xD[0] */
double to_node[6];      /* 1-dim C array */
double dist_to;         /* distance to the target node */
int    reached_path_end;  /* boolean: whether we've reached the path end */ 

reached_path_end = xD[2];

if (exec_path[0] == 0) {
    /* reset internal states */
    xD[0] = 0;
    xD[1] = 99999;
    xD[2] = 0;
    return;
}

/* kill it here if we've finished the path. */
if (reached_path_end == 1) return;

path_ind = xD[0];
prev_dist_to = xD[1];

/* copy the nodes from the path */
for (i=0; i<6; i++) {
    to_node[i] = path[(path_ind+1)*6 + i];
}

/* check that we haven't yet passed the destination waypoint */

dist_to = sqrt( pow(to_node[0]-pose[0],2) + pow(to_node[1]-pose[1],2));

if (dist_to > prev_dist_to) {
    path_ind = path_ind + 1;
    xD[0] = path_ind;      /* increment path index */
    xD[1] = 99999;          /* reset dist_to_next */
    
    /* if we're NOT at the end of a path of length 20... */
    if (path_ind != 19) {
        /* check whether all that remains of the path is zeros */
        reached_path_end = 1;
        for (i=0; i<6; i++) {
            if (path[(path_ind+1)*6 + i] != 0) {
                reached_path_end = 0;
                break;
            }
        }
    }
    
    if (reached_path_end == 1 || path_ind == 19) {
        xD[2] = 1;
//         mexPrintf("PATH_FOL_UPDT: ind=%d, reached terminal node.\n", path_ind);
        return;
    }
    
//     mexPrintf("PATH_FOL_UPDT: ind=%d, dist=%.2f, reached next node\n", path_ind, dist_to);   
    return;
} else {
    xD[1] = dist_to;        /* overwrite dist_to_next */
    
//     mexPrintf("PATH_FOL_UPDT: ind=%d, dist=%.2f, update dist\n", path_ind, dist_to);    
    return;
}
/* %%%-SFUNWIZ_wrapper_Update_Changes_END --- EDIT HERE TO _BEGIN */
}
